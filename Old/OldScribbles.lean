import Mathlib.Order.Birkhoff
import Mathlib.Order.GaloisConnection

open LatticeHom Set
variable (α : Type)
variable [DistribLattice α] [Fintype α] [DecidableEq α] [@DecidablePred α SupIrred]


-- TODO: Make this an abbreviation
def J := {a : α // SupIrred a}

example : PartialOrder {a : α // SupIrred a} := Subtype.partialOrder fun a ↦ SupIrred a

#check OrderIso.lowerSetSupIrred
-- example (f : α → α) : range f = range f := by sorry
-- TODO Perhaps find a way to use `birkhoffFinset` rather than `birkhoffSet`
lemma InImageBirkhoffIff (u : (Set ({a : α // SupIrred a}))) :
  u ∈ range (birkhoffSet α) ↔ IsLowerSet u := by sorry

/- (in this proof blueprint below, just for readability,
I write f for birkhoffSet and J α for {a : α // SupIrred a} )
first suppose u = f a for some a : α.
we show that f a is a lower set.
suppose x ∈ f a and y : J α  with y ≤ x.
by def of f a, x ≤ a.
now y ≤ a by transitivity.
thus,  y ∈ f a as required.

conversely, suppose u is a lower set.
we define a := sup u, and we claim that f(sup u) = u.
let x : J α. We have:
x ∈ f (sup u) ↔ x ≤ sup u (definition of f)
↔ x ≤ y for some y ∈ u (lemma about join-prime in distributive lattices)
↔ x ∈ u (since u is a lower set)
-/

/- Actually, I just realized that the above proof is already in mathlib under `OrderIso.lowerSetSupIrred`. -/


/- There is also
"the other unitor of Birkhoff's representation theorem"
`noncomputable def OrderIso.supIrredLowerSet`
but it only applies to α which is DistribLattice, and this is not general enough.
In order to establish the dual equivalence between finite DL's and finite posets, what we will
need is the following statement, which is strictly more general: -/

variable (β : Type)
variable [PartialOrder β] [Fintype β]
noncomputable def OrderIso.supIrredLowerSet' :
  β ≃o {s : LowerSet β // SupIrred s} := sorry




/- NB: there is a similar statement to the above proposition in Mathlib,
but it is not general enough, as it only treats
the case where P is a distributive lattice. But all that is needed is that P is a finite poset. -/
#check OrderIso.supIrredLowerSet

-- To prove Proposition~{EssSurjFinDL}, we will need:
-- A join-irreducible`SupIrred` element of the lattice of lower sets has a unique maximal element.
-- TODO is it in the library?
-- lemma maximalElementOfJoinIrreducibleLowerSet {s : LowerSet P} (h : SupIrred s) :
--   { m : P // m ∈ s ∧ ∀ (p : P), p ∈ s → p ≤ m } := by sorry

-- since s is LowerSet, it is a union of the lower sets generated by its maximal elements
-- lemma lowerSetGeneratedByMaxElements {s : LowerSet P} :
-- s = ⋃ { lowerClosure p | p ∈ max s } := sorry

noncomputable def topOfJoinIrreducibleLowerSet {s : LowerSet P} (h_irred : SupIrred s) : s := by
-- since s = union of {p} for p ranging over s,

-- lowerClosure s = lowerClosure (union of {p} for p ranging over s)
-- but s = lowerClosure s (since s is a LowerSet)
-- and the RHS can be expanded to:
-- union (lowerClosure {p}) for p ranging over s by a lemma in the library
-- but now s is supIrred so we get s = lowerclosure {p} for some p.

  haveI fins : Fintype s.1 := sorry
  -- we want to somewhere separate out this f because it is used several times.
  have f : P -> LowerSet P := fun p => lowerClosure {p}
  have seqsupf : Finset.sup s.1.toFinset f = s := sorry -- ⋁ f[s] = s
  have existsi := SupIrred.finset_sup_eq h_irred seqsupf

  -- TODO: here we had some trouble because the existsi term is not a Prop.
  -- TODO: we should also not need axiom of choice to choose an element in a finite set with 1 element!!!
  set x := existsi.choose with hx0
  have hx := existsi.choose_spec
  rw [←hx0] at hx
  use x
  simp_all
-- since s is LowerSet, it is a union of the lower sets generated by its maximal elements
-- since s is SupIrred, this union can only consist of a single set
-- the element generating that single set must be the top of s.

lemma topOfJILSisTop {s : LowerSet P} (h_irred : SupIrred s) :
  IsTop (topOfJoinIrreducibleLowerSet P h_irred) := sorry

-- NB most of the work above is in fact already done here:
-- #check LowerSet.supIrred_iff_of_finite
