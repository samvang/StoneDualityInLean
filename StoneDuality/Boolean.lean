import Mathlib.Topology.Category.Profinite.Basic
import Mathlib.Order.Category.BoolAlg
import StoneDuality.HomClosed
import Mathlib.Topology.Sets.Closeds
-- import Mathlib.Topology.Compactness.Compact

open CategoryTheory TopologicalSpace

open scoped Classical
noncomputable section

namespace StoneDuality

@[simps obj]
def Clp : Profinite·µí·µñ ‚•§ BoolAlg where
  obj S := BoolAlg.of (Clopens S.unop)
  map f := by
    refine ‚ü®‚ü®‚ü®fun s ‚Ü¶ ‚ü®f.unop ‚Åª¬π' s.1, IsClopen.preimage s.2 f.unop.2‚ü©, ?_‚ü©, ?_‚ü©, ?_, ?_‚ü©
    all_goals intros; congr

@[simp] -- the one generated by `simps` was too ugly
lemma Clp_map_toLatticeHom_toSupHom_toFun_coe {X Y : Profinite·µí·µñ} (f : X ‚ü∂ Y) (s : Clopens X.unop) :
  (Clp.map f s).carrier = f.unop ‚Åª¬π' s.carrier := by rfl

namespace Spec

open BoolAlg

variable (A : BoolAlg)

def basis : Set (Set (A ‚ü∂ of Prop)) :=
  let U : A ‚Üí Set (A ‚ü∂ of Prop) := fun a ‚Ü¶ {x | x.1 a = ‚ä§}
  Set.range U

instance instTopHomBoolAlgProp : TopologicalSpace (A ‚ü∂ of Prop) := generateFrom <| basis A
  --induced (fun f ‚Ü¶ (f : A ‚Üí Prop)) (Pi.topologicalSpace (t‚ÇÇ := fun _ ‚Ü¶ ‚ä•))

theorem basis_is_basis : IsTopologicalBasis (basis A) where
  exists_subset_inter := by
    rintro t‚ÇÅ ‚ü®a‚ÇÅ, rfl‚ü© t‚ÇÇ ‚ü®a‚ÇÇ, rfl‚ü© x hx
    simp only [BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, eq_iff_iff, Set.mem_inter_iff,
      Set.mem_setOf_eq] at hx
    refine ‚ü®{x | x.1.1.1 (a‚ÇÅ ‚äì a‚ÇÇ) = ‚ä§}, ‚ü®(a‚ÇÅ ‚äì a‚ÇÇ), rfl‚ü©, ?_, ?_‚ü©
    ¬∑ simp only [BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, eq_iff_iff, Set.mem_setOf_eq]
      rw [x.map_inf']
      tauto
    ¬∑ intro y (hy : y.1.1.1 _ = ‚ä§)
      rw [y.map_inf'] at hy
      simp only [BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, inf_Prop_eq, eq_iff_iff] at hy
      simp only [BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, eq_iff_iff, Set.mem_inter_iff,
        Set.mem_setOf_eq]
      tauto
  sUnion_eq := by
    rw [Set.sUnion_eq_univ_iff]
    intro x
    simp only [basis, BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, eq_iff_iff, Set.mem_range,
      exists_exists_eq_and, Set.mem_setOf_eq]
    exact ‚ü®‚ä§, eq_iff_iff.mp x.2‚ü©
  eq_generateFrom := rfl

noncomputable def emb : (A ‚ü∂ of Prop) ‚Üí (A ‚Üí Bool) := fun f a ‚Ü¶ decide (f a)


-- TODO: Check that with
-- attribute [-instance] sierpinskiSpace
-- def discreteProp : TopologicalSpace Prop := sorry
-- the following might replace `emb` still being continuous
def emb' : (A ‚ü∂ of Prop) ‚Üí (A ‚Üí Prop) := (¬∑)

instance (A : BoolAlg) : BooleanAlgebra ((forget BoolAlg).obj A) :=
  (inferInstance : BooleanAlgebra A)

instance (A B : BoolAlg) : BoundedLatticeHomClass (A ‚ü∂ B) A B :=
  (inferInstance : BoundedLatticeHomClass (BoundedLatticeHom A B) A B)

instance (A B : BoolAlg) :
    BoundedLatticeHomClass (A ‚ü∂ B) A ((forget BoolAlg).obj B) :=
  (inferInstance : BoundedLatticeHomClass (BoundedLatticeHom A B) A B)

instance (A B : BoolAlg) :
    BoundedLatticeHomClass (A ‚ü∂ B) ((forget BoolAlg).obj A) B :=
  (inferInstance : BoundedLatticeHomClass (BoundedLatticeHom A B) A B)

instance (A B : BoolAlg) :
    BoundedLatticeHomClass (A ‚ü∂ B) ((forget BoolAlg).obj A) ((forget BoolAlg).obj B) :=
  (inferInstance : BoundedLatticeHomClass (BoundedLatticeHom A B) A B)

theorem continuous_emb : Continuous (emb A) := by
  apply continuous_pi
  intro a
  simp only [emb, BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of]
  rw [continuous_discrete_rng]
  rintro ‚ü®‚ü©
  ¬∑ refine (basis_is_basis A).isOpen ‚ü®a·∂ú, ?_‚ü©
    ext x
    have hc := map_compl' x a
    rw [eq_iff_iff, compl_iff_not] at hc -- why doesn't `simp` work?
    simpa [Prop.top_eq_true] using hc
  ¬∑ refine (basis_is_basis A).isOpen ‚ü®a, ?_‚ü©
    ext x
    simp only [BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, Prop.top_eq_true, eq_iff_iff,
      iff_true, Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff, decide_eq_true_eq]
    rfl

theorem inducing_emb : Inducing (emb A) where
  induced := by
    refine eq_of_ge_of_not_gt (le_generateFrom fun s hs ‚Ü¶ ?_)
        (not_lt_of_le (continuous_emb _).le_induced)
    rw [isOpen_induced_iff]
    obtain ‚ü®a, rfl‚ü© := hs
    refine ‚ü®Set.pi {a} fun _ ‚Ü¶ {true}, ?_, ?_‚ü©
    ¬∑ exact isOpen_set_pi (Set.finite_singleton _) fun _ _ ‚Ü¶ trivial
    ¬∑ ext x
      simp only [Bool.univ_eq, Set.singleton_pi, ‚ÜìreduceIte, Set.mem_preimage, Function.eval, emb,
        Set.mem_singleton_iff, decide_eq_true_eq, BddDistLat.coe_toBddLat, coe_toBddDistLat,
        coe_of, Prop.top_eq_true, eq_iff_iff, iff_true, Set.mem_setOf_eq]
      rfl


theorem closedEmbedding_emb : ClosedEmbedding (emb A) := by
  refine closedEmbedding_of_continuous_injective_closed ?_ ?_ ?_
  ¬∑ exact continuous_emb _
  ¬∑ intro _ _ h
    ext
    rw [eq_iff_iff]
    simpa [emb] using congrFun h _
  ¬∑ refine (inducing_emb _).isClosedMap ?_
    let J : A ‚Üí A ‚Üí (Set (A ‚Üí Bool)) := fun a b ‚Ü¶ {x | x (a ‚äî b) = (x a ‚à® x b)}
    let I : A ‚Üí A ‚Üí (Set (A ‚Üí Bool)) := fun a b ‚Ü¶ {x | x (a ‚äì b) = (x a ‚àß x b)}
    let T : Set (A ‚Üí Bool) := {x | x ‚ä§ = true}
    let B : Set (A ‚Üí Bool) := {x | x ‚ä• = false}
    have : Set.range (emb A) = (‚ãÇ (a : A) (b : A), J a b) ‚à© (‚ãÇ (a : A) (b : A), I a b) ‚à© T ‚à© B := by
      ext x
      constructor
      ¬∑ rintro ‚ü®x, rfl‚ü©
        simp only [Bool.decide_coe, Set.mem_inter_iff,
          Set.mem_iInter, Set.mem_setOf_eq, emb, map_sup, map_inf, map_top, decide_eq_true_eq,
          map_bot, decide_eq_false_iff_not]
        rw [Prop.top_eq_true, Prop.bot_eq_false]
        simp only [and_true, not_false_eq_true]
        refine ‚ü®fun a b ‚Ü¶ ?_, fun a b ‚Ü¶ ?_‚ü©
        all_goals congr
      ¬∑ intro ‚ü®‚ü®‚ü®h_map_sup, h_map_inf‚ü©, h_map_top‚ü©, h_map_bot‚ü©
        refine ‚ü®‚ü®‚ü®‚ü®fun a ‚Ü¶ (x a : Prop), ?_‚ü©, ?_‚ü©, ?_, ?_‚ü©, ?_‚ü©
        ¬∑ simp only [Set.mem_iInter, Set.mem_setOf_eq] at h_map_sup
          simp [h_map_sup]
        ¬∑ simp only [Set.mem_iInter, Set.mem_setOf_eq] at h_map_inf
          simp [h_map_inf]
        ¬∑ simpa [Prop.top_eq_true] using h_map_top
        ¬∑ simpa [Prop.bot_eq_false] using h_map_bot
        ¬∑ ext a
          simp only [emb, BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of]
          have : (decide (x a = true)) = x a := by simp only [Bool.decide_coe]
          rw [‚Üê this]
          congr
    rw [this]
    refine IsClosed.inter (IsClosed.inter (IsClosed.inter ?_ ?_) ?_) ?_
    ¬∑ refine isClosed_iInter (fun i ‚Ü¶ isClosed_iInter (fun j ‚Ü¶ ?_))
      simp only [Bool.decide_or, Bool.decide_coe]
      exact (IsClosed_PreserveBinary_T2 i j (Sup.sup) (or) (by continuity))
    ¬∑ refine isClosed_iInter (fun i ‚Ü¶ isClosed_iInter (fun j ‚Ü¶ ?_))
      simp only [Bool.decide_and, Bool.decide_coe]
      exact (IsClosed_PreserveBinary_T2 i j (Inf.inf) (and) (by continuity))
    ¬∑ exact (IsClosed_PreserveNullary_T1 ‚ä§ true)
    ¬∑ exact (IsClosed_PreserveNullary_T1 ‚ä• false)

lemma mem_basis (p : Prop) : {x : A ‚ü∂ of Prop | x a = p} ‚àà basis A := by
  cases Classical.dec p with
  | isFalse h =>
    have : p = ‚ä• := Mathlib.Meta.NormNum.eq_of_false h fun a ‚Ü¶ a
    rw [this]
    use a·∂ú
    ext x
    simp only [BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, Prop.top_eq_true, eq_iff_iff,
      iff_true, Set.mem_setOf_eq]
    rw [eq_iff_iff]
    simp only [Prop.bot_eq_false, iff_false]
    rw [‚Üê compl_iff_not, ‚Üê map_compl' x a ]
    rfl
  | isTrue h =>
    have : p = ‚ä§ := propext { mp := fun _ ‚Ü¶ trivial, mpr := fun _ ‚Ü¶ h }
    rw [this]
    use a
    ext x
    simp only [BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, eq_iff_iff, Set.mem_setOf_eq]
    rw [eq_iff_iff]
    simp only [Prop.top_eq_true, Prop.bot_eq_false, iff_false, iff_true]
    rfl

instance : CompactSpace (A ‚ü∂ of Prop) where
  isCompact_univ := by
    let K := Set.range (emb A)
    have hK : IsCompact K := (closedEmbedding_emb A).closed_range.isCompact
    rw [‚Üê Set.preimage_range]
    exact (closedEmbedding_emb A).isCompact_preimage hK

instance : TotallySeparatedSpace (A ‚ü∂ of Prop) where
  isTotallySeparated_univ := by
    intro x _ y _ h
    rw [DFunLike.ne_iff] at h
    obtain ‚ü®a, ha‚ü© := h
    refine ‚ü®{z | z a = x a}, {z | z a = y a}, ?_‚ü©
    refine ‚ü®(basis_is_basis A).isOpen (mem_basis _ _), (basis_is_basis A).isOpen (mem_basis _ _),
      rfl, rfl, ?_, ?_‚ü©
    ¬∑ intro z _
      simp
      cases Classical.dec (x a) with
      | isFalse h =>
        have : x a = ‚ä• := Mathlib.Meta.NormNum.eq_of_false h fun a ‚Ü¶ a
        rw [this]
        have hy : y a = ‚ä§ := by
          rw [Prop.bot_eq_false, eq_iff_iff] at this
          rw [this] at ha
          simp at ha
          rw [eq_iff_iff] at ha
          simp at ha
          rw [Prop.top_eq_true, eq_iff_iff]
          simpa using ha
        rw [hy, eq_iff_iff, eq_iff_iff, Prop.top_eq_true, Prop.bot_eq_false]
        simpa using em' (z a)
      | isTrue h =>
        have : x a = ‚ä§ := top_unique fun a ‚Ü¶ h
        rw [this]
        have hy : y a = ‚ä• := by
          rw [Prop.top_eq_true, eq_iff_iff] at this
          rw [this] at ha
          simp at ha
          rw [eq_iff_iff] at ha
          simp at ha
          rw [Prop.bot_eq_false, eq_iff_iff]
          simpa using ha
        rw [hy, eq_iff_iff, eq_iff_iff, Prop.top_eq_true, Prop.bot_eq_false]
        simpa using (em' (z a)).symm
    ¬∑ rw [Set.disjoint_iff]
      intro z ‚ü®hxz, hyz‚ü©
      simp only [BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, eq_iff_iff, Set.mem_setOf_eq]
        at hxz
      simp only [BddDistLat.coe_toBddLat, coe_toBddDistLat, coe_of, eq_iff_iff, Set.mem_setOf_eq]
        at hyz
      rw [hxz] at hyz
      exact ha hyz

-- Is this really not in mathlib?
instance TotallySeparatedSpace.t2Space (Œ± : Type*) [TopologicalSpace Œ±] [TotallySeparatedSpace Œ±] :
    T2Space Œ± where
  t2 x y h := by
    obtain ‚ü®u, v, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ, _, h‚ÇÖ‚ü© :=
      TotallySeparatedSpace.isTotallySeparated_univ x (by triv) y (by triv) h
    exact ‚ü®u, v, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ, h‚ÇÖ‚ü©

end Spec

open Spec

theorem Spec_map_cont {X Y : BoolAlg} (f : Y ‚ü∂ X) :
    Continuous fun (y : X ‚ü∂ BoolAlg.of Prop) ‚Ü¶ f ‚â´ y := by
  rw [continuous_generateFrom_iff]
  rintro _ ‚ü®a, rfl‚ü©
  exact isOpen_generateFrom_of_mem ‚ü®f a, rfl‚ü©

@[simps]
def Spec : BoolAlg·µí·µñ ‚•§ Profinite where
  obj A := Profinite.of (A.unop ‚ü∂ BoolAlg.of Prop)
  map f := ‚ü®fun y ‚Ü¶ f.unop ‚â´ y, Spec_map_cont f.unop‚ü©

-- ## Definition of epsilon
def epsilonObjObj {X : Profinite} (x : X) : BoundedLatticeHom (Clopens X) Prop
where
  toFun := fun K ‚Ü¶ (x ‚àà K)
  map_sup' := by intros; rfl
  map_inf' := by intros; rfl
  map_top' := by intros; rfl
  map_bot' := by intros; rfl

lemma preimage_epsilonObjObj_eq {X : Profinite} (a : Clopens X) :
  (epsilonObjObj ‚Åª¬π' {x | x.toLatticeHom a ‚Üî ‚ä§}) = a := Set.ext fun _ ‚Ü¶ iff_true_iff


def epsilonCont {X : Profinite} : ContinuousMap X (Profinite.of
   (BoolAlg.of (Clopens X) ‚ü∂ (BoolAlg.of Prop))) where
     toFun := epsilonObjObj
     continuous_toFun := by
      let A := BoolAlg.of (Clopens X)
      let hB := basis_is_basis A
      rw [TopologicalSpace.IsTopologicalBasis.continuous_iff hB]
      intro U hU
      simp only [basis, BoolAlg.coe_of, BddDistLat.coe_toBddLat, BoolAlg.coe_toBddDistLat,
        eq_iff_iff, Set.mem_range] at hU
      obtain ‚ü®a, ha‚ü© := hU
      simp_rw [‚Üê ha]
      have : (epsilonObjObj ‚Åª¬π' {x | x.toLatticeHom a ‚Üî ‚ä§}) = a := Set.ext fun _ ‚Ü¶ iff_true_iff
      erw [this]
      exact (Clopens.isClopen a).2

-- TODO move somewhere?
lemma coerce_bijective [TopologicalSpace X] [TopologicalSpace Y] (f : ContinuousMap X Y) (h : Function.Bijective f.toFun) : Function.Bijective f := by constructor; exact h.1; exact h.2

-- TODO move to Order/Hom/Lattice.lean
theorem BoundedLatticeHom.ext_iff {Œ± Œ≤ : Type*} [Lattice Œ±] [Lattice Œ≤] [BoundedOrder Œ±] [BoundedOrder Œ≤] {f g : BoundedLatticeHom Œ± Œ≤ } : f = g ‚Üî ‚àÄ x, f x = g x :=
  DFunLike.ext_iff


-- this is proved in a newer version of Mathlib
theorem IsCompact.nonempty_sInter_of_directed_nonempty_isCompact_isClosed' {X : Type u} [TopologicalSpace X]
    {S : Set (Set X)} [hS : Nonempty S] (hSd : DirectedOn (¬∑ ‚äá ¬∑) S) (hSn : ‚àÄ U ‚àà S, U.Nonempty)
    (hSc : ‚àÄ U ‚àà S, IsCompact U) (hScl : ‚àÄ U ‚àà S, IsClosed U) : (‚ãÇ‚ÇÄ S).Nonempty := by sorry


-- TODO: add to Profinite/Basic
@[simp]
lemma Profinite.coe_of (X : Type*) [TopologicalSpace X] [CompactSpace X] [T2Space X]
    [TotallyDisconnectedSpace X] : (Profinite.of X).toCompHaus = CompHaus.of X :=
  rfl

-- HELP
theorem coercionhell {X : Profinite} (F G :
‚Üë(Profinite.of (BoolAlg.of (Clopens ‚ÜëX.toCompHaus.toTop) ‚ü∂ BoolAlg.of Prop)).toCompHaus.toTop)
(h : F.toFun = G.toFun) : F = G := by
  dsimp only [Profinite.coe_of, CompHaus.coe_of]
  ext x
  rw [Function.funext_iff] at h
  exact h x



-- A bounded lattice homomorphism of Boolean algebras preserves negation.
-- theorem map_neg_of_bddlathom {A B : BoolAlg} (f : A ‚ü∂ B) (a : A) : f (¬¨ a) = ¬¨ f a := by sorry

--TODO: prove surjectivity

-- TODO I didn't feel like searching in the library again
lemma contrapose (A B : Prop) : (A ‚Üí B) ‚Üí (¬¨ B ‚Üí ¬¨ A) := fun h a a_1 ‚Ü¶ a (h a_1)

lemma epsilonSurj {X : Profinite} : Function.Surjective (@epsilonCont X).toFun := by
    intro F
    set Fclp : Set (Clopens X) := (F.toFun)‚Åª¬π' {True} with Fclpeq
    set asSets : Set (Set X) := Clopens.Simps.coe '' Fclp with hClp
    set K : Set X := Set.sInter asSets with Keq
    haveI : Nonempty asSets := by
      use Set.univ
      rw [hClp]
      use ‚ä§
      constructor
      have : F.toFun ‚ä§ := by rw [F.map_top']; trivial
      simp only [BddDistLat.coe_toBddLat, BoolAlg.coe_toBddDistLat, BoolAlg.coe_of,
        Set.preimage_singleton_true, Set.mem_setOf_eq]
      trivial
      trivial

    have hK : IsClosed K := by
      rw[Keq]
      apply isClosed_sInter
      rw [hClp]
      simp
      intro a ha
      exact a.2.1
    have Xiscompact := X.toCompHaus.is_compact.isCompact_univ

    have hSd : DirectedOn (fun (x x_1 : Set X) => x ‚äá x_1) asSets := by sorry
    have hSn : ‚àÄ U ‚àà asSets, Set.Nonempty U := by sorry
    have hSc : ‚àÄ U ‚àà asSets, IsCompact U := by sorry
    have hScl : ‚àÄ U ‚àà asSets, IsClosed U := by sorry

    have Kne : K.Nonempty := by
      refine IsCompact.nonempty_sInter_of_directed_nonempty_isCompact_isClosed' hSd hSn hSc hScl
    obtain ‚ü®x, hx‚ü© := Kne
    use x
    simp only [epsilonCont, epsilonObjObj]
    dsimp only [Profinite.coe_of, CompHaus.coe_of]
    apply coercionhell
    simp only [BddDistLat.coe_toBddLat, BoolAlg.coe_toBddDistLat, BoolAlg.coe_of]
    ext L

    have inF_implies_xin (U : Clopens X) (h : F.toFun U) : x ‚àà U := by
      have : K ‚äÜ U := by
        rw[Keq, hClp]
        apply Set.sInter_subset_of_mem
        simp only [BddDistLat.coe_toBddLat, BoolAlg.coe_toBddDistLat, BoolAlg.coe_of,
          Set.preimage_singleton_true, Set.mem_image, Set.mem_setOf_eq]
        use U
        exact ‚ü®h, by trivial‚ü©
      exact this hx

    have key (U : Clopens X) : U ‚àà Fclp ‚Üî x ‚àà U := by
      rw [Fclpeq]
      simp only [BddDistLat.coe_toBddLat, BoolAlg.coe_toBddDistLat, BoolAlg.coe_of,
        Set.preimage_singleton_true, Set.mem_setOf_eq]
      constructor
      ¬∑ apply inF_implies_xin
      ¬∑ intro h

        -- by_contra hnot
        -- have UcompinF : F.toFun (U·∂ú : Clopens X) :=  by

        --   sorry -- because F preserves negation
        have := inF_implies_xin (U·∂ú)
        sorry


        -- exact this

    constructor
    ¬∑ intro hxL
      rw [‚Üê key, Fclpeq] at hxL
      simp only [BddDistLat.coe_toBddLat, BoolAlg.coe_toBddDistLat, BoolAlg.coe_of,
        Set.preimage_singleton_true, Set.mem_setOf_eq] at hxL
      exact hxL
    ¬∑ intro hFL
      rw [‚Üê key]
      rw [Fclpeq]
      simp only [BddDistLat.coe_toBddLat, BoolAlg.coe_toBddDistLat, BoolAlg.coe_of,
        Set.preimage_singleton_true, Set.mem_setOf_eq]
      exact hFL




def epsilonObj {X : Profinite} : X ‚âÖ (Profinite.of (BoolAlg.of (Clopens X) ‚ü∂ (BoolAlg.of Prop))) :=
  by
  refine Profinite.isoOfBijective epsilonCont ?_
  apply coerce_bijective
  constructor
  ¬∑ intro x y
    simp only [epsilonCont]
    rw [BoundedLatticeHom.ext_iff]
    contrapose!
    intro hne
    obtain ‚ü®K, hK‚ü© := exists_isClopen_of_totally_separated hne
    exists ‚ü®K, hK.1‚ü©
    simp only [ne_eq, eq_iff_iff, epsilonObjObj, BoundedLatticeHom.coe_mk, LatticeHom.coe_mk,
    SupHom.coe_mk, Clopens.mem_mk]
    push_neg
    left
    exact hK.2
  ¬∑ exact epsilonSurj


def epsilon : ùü≠ Profinite ‚âÖ Clp.rightOp ‚ãô Spec := by
  refine NatIso.ofComponents (fun X ‚Ü¶ epsilonObj) ?_
  -- TODO: prove naturality
  sorry

-- ## Definition of eta
def etaObjObjSet {A : BoolAlg} (a : A) :
  Set (Profinite.of (A ‚ü∂ BoolAlg.of Prop)) := { x | x.toFun a = ‚ä§ }

def IsClopen_etaObjObj {A : BoolAlg} (a : A)  : IsClopen (etaObjObjSet a) := by
  constructor
  ¬∑ sorry -- TODO: show that eta a is closed
  ¬∑ sorry -- TOOD: show that eta a is open

def etaObjObj {A : BoolAlg} (a : A) : (BoolAlg.of (Clopens (Profinite.of (A ‚ü∂ BoolAlg.of Prop)))) := by
  refine ‚ü®etaObjObjSet a, IsClopen_etaObjObj a‚ü©

-- the following is probably already in library somewhere (we'll need the same for inf, top and bot)
lemma supeqtop (a b : Prop) : a ‚äî b = ‚ä§ ‚Üî a = ‚ä§ ‚à® b = ‚ä§ := by
  rw [Prop.top_eq_true]
  simp only [sup_Prop_eq, eq_iff_iff, iff_true]

def etaObj_real {A : BoolAlg} : A ‚ü∂ (BoolAlg.of (Clopens (Profinite.of (A ‚ü∂ BoolAlg.of Prop)))) where
  toFun := etaObjObj
  map_sup' := by
    intros a b
    simp only [BddDistLat.coe_toBddLat, BoolAlg.coe_toBddDistLat, BoolAlg.coe_of, etaObjObj,
     etaObjObjSet]
    ext x
    simp only [Clopens.coe_mk, Clopens.coe_sup, Set.mem_union, Set.mem_setOf_eq]
    rw [x.map_sup']
    apply supeqtop
  -- TODO: fill these (but hopefully can shorten the above proof?)
  map_inf' := sorry
  map_top' := sorry
  map_bot' := sorry

-- TODO: I am stuck with all the op's and rightOp's from here on... help
def etaObj_hom {A : BoolAlg·µí·µñ} : (ùü≠ BoolAlg·µí·µñ).toPrefunctor.obj A ‚ü∂ (Spec ‚ãô Clp.rightOp).toPrefunctor.obj A := by
  simp
  have f := @etaObj_real A.unop
  sorry

def etaObj {A : BoolAlg·µí·µñ} : (ùü≠ BoolAlg·µí·µñ).toPrefunctor.obj A ‚âÖ (Spec ‚ãô Clp.rightOp).toPrefunctor.obj A
  := by
    refine Iso.mk ?_ ?_ ?_ ?_
    all_goals sorry

def eta : ùü≠ BoolAlg·µí·µñ ‚âÖ Spec ‚ãô Clp.rightOp := by
  refine NatIso.ofComponents (fun A ‚Ü¶ etaObj) ?_
  sorry


theorem triangle : ‚àÄ (X : Profinite),
  Clp.rightOp.map (epsilon.hom.app X) ‚â´ eta.symm.hom.app (Clp.rightOp.obj X) =
    ùüô (Clp.rightOp.obj X) := by
    intro X
    sorry

def Equiv : Profinite ‚âå BoolAlg·µí·µñ where
  functor := Clp.rightOp
  inverse := Spec
  unitIso := epsilon
  counitIso := eta.symm
  functor_unitIso_comp := triangle

end StoneDuality
